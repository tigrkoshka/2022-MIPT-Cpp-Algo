### Общее описание алгоритмов

Во всех задачах используются так называемый backtracking-алгоритмы.

Этот подход применим, когда задача удовлетворяет следующим условиям:

* Суть задачи заключается в переборе некоторых вариантов чего-либо


* Для вариантов определено в каком-то смысле понятие префиксов. Будем говорить, 
  что варианты объединяются в группы по признаку общего префикса


* Решение задач для каждой группы (автоматически или вычислительно просто) сводится к решению аналогичной задачи
  меньшей размерности (условие применимости рекурсии или динамического программирования)


* Некоторые варианты являются невалидными, причем если вариант невалиден, то все другие варианты 
  из какой-то группы, в которой он находится, автоматически также являются невалидными

  или

  Некоторые варианты попадают в один класс эквивалентности (определённый в каком-то смысле условием задачи)
  с другими, а по условию задачи нам нужно выводить только одного представителя каждого класса эквивалентности

```
Для данных задач:

1. Перестановки с повторениями:

   - Вариантами являются сами перестановки
 
   - Для перестановок определены префиксы в смысле префиксов массивов
   
   - Для каждой группы решение автоматически сводится к решению подзадачи о нахождении всех различных перестановок 
     оставшихся (то есть не содержащихся в общем для группы префиксе) элементов 
    
   - Перестановки, одинаковые с точностью до перестановок между равными элементами, попадают в один класс эквивалентности,
     а по условию нам нужно выводить только уникальные перестановки

    
2. Подмножества с повторениями:

   - Вариантами являются сами подмножества
  
   - Для подмножеств префиксы определены в смысле теоретико-множественного включения
   
   - Для каждой группы решение автоматически сводится к решению подзадачи о нахождении всех различных подмножеств 
     оставшихся (то есть не содержащихся в общем для группы префиксе) элементов
  
   - Подмножества, одинаковые с точностью до замены некоторых элементов на равные им, попадают в один класс эквивалентности,
     а по условию нам нужно выводить только уникальные подмножества


3. Правильные скобочные последовательности:

   - Вариантами являются сами последовательности
  
   - Для последовательностей определены префиксы в смысле префиксов строк
   
   - Для каждой группы решение автоматически сводится к решению подзадачи о нахождении всех различных скобочных последовательностей 
     с нужным скобочным балансом (уравновешивающим баланс общего для группы префикса) из оставшихся (не входящих в префикс) скобок
    
   - Если какая-то скобочная последовательность невалидна, то это значит, что существует её минимальный префикс,
     на котором скобочный баланс стал отрицательным, тогда все последовательности с таким префиксом являются невалидными


4. Судоку:

   - Вариантами являются расстановки чисел на свободные клетки

   - Для расстановок можно определить префиксы как неполные расстановки (содержащие пестые клетки), у которых все
     расставленные элементы совпадают с элементами на тех же позициях у исходной расстановки
     
   - Для каждой группы решение автоматически сводится к решению подзадачи о заполнении оставшихся незаполненных (в общем для группы префиксе) клеток
     (то есть аналогичной задачи, в которой на вход приходит доска с бóльшим количеством исходно заполненных клеток)

   - Если какая-то расстановка чисел невалидна, то это значит, что в каком-то ряду, столбце или квадрате 3x3 дважды встретилось
     одно и то же число, тогда все последовательности из группы с зафиксированными этими двумя позициями невалдины
```

В таком случае в зависимости от того, какое из условий третьего пункта выполняется, возникает две идеи:

* В случае с отсеиванием некоторых вариантов хочется придумать способ обхода, позволяющий пропускать заведомо невалидные варианты,
  идентифицируя их по вариантам из той же группы, а не посещать все возможные варианты и каждый валидировать.

  В этом случае такие задачи часто удобно решать рекурсией, постепенно удлиняя префикс, тогда каждая ветка рекурсии будет
  соответствовать группе вариантов, и мы сможем легко переложить рассуждение выше на простое отсекание некоторых веток.


* В случае с классами эквивалентности над множеством вариантов, хочется придумать способ обхода,
  чтобы попадать только в одного представителя каждого класса эквивалентности, а не проверять для каждого нового варианта,
  был ли эквивалентный ему уже учтён.

  В этом случае часто логика нужного обхода вариантов тесно связана с принципом построения классов эквивалентности

```
Для данных задач:

1. Перестановки с повторениями:

   Заведём счётчики на каждый уникальный элемент, показывающие, сколько раз он встречается в исходном массиве.
   Теперь при рекурсивном построении перестановок забудем про исходный массив, и будем пользоваться только этими счётчиками.
   Таким образом мы перейдём с языка элементов на язык классов эквивалентности перестановок (мы теперь никак не различаем равные элементы),
   и тогда просто по построению мы будем получать только по одному представителю на каждый класс

2. Подмножества с повторениями:

   Отсортировав предварительно заданный массив, при рекурсивном построении перестановок будем на одном уровне рекурсии в каждом подмассиве
   одинаковых элементов пропускать все, кроме первого. Таким образом мы на каждом уровне рекурсии перестаём различать равные элементы,
   то есть переходим к языку класов эквивалентности (мы различаем только количество одинаковых элементов в подмножестве, 
   но не их индексы в исходном массиве), и тогда просто по построению мы будем получать только по одному представителю класса

3. Правильные скобочные последовательности:

   При рекурсивном построении скобочных последовательностей, не будем заходить в те ветки рекурсии, в которых скобочный баланс становится
   отрицательным, или в которых остаются только закрывающие скобки (просто будем добавлять в ответ наш префикс с ними на конце и возвращаться
   на предыдущий уровень). Таким образом мы отсекаем заведомо невалидные варианты.

4. Судоку:

   При рекурсивном переборе вариантов заполнении доски, не будем заходить в ветки рекурсии, в которых заведомо нет валидных заполнений,
   то есть которые соответствуют неполным заполнениям с повторяющимися в строке, стобце или квадрате 3x3 элементами
```

Кроме того, поскольку такие задачи связаны с перебором вариантов, часто в них ответы складываются в контейнер,
размер которого экспоненциально или через факториал зависит от длины входа (по крайней мере в худшем случае),
поэтому, чтобы избежать большого количества реаллокаций, часто выгодно предпосчитать финальный размер этого контейнера
и сразу аллоцировать под него место (так и сделано в первых трёх задачах). Тут важно несколько идей:

* Речь идёт о неасимптотической оптимизации худшего случая, поэтому если вы уверены, что ваши входные данные "хорошие",
  то стоит задуматься перед её применением, возможно, сложность предподсчёта итоговой длины контейнера в вашем случае
  будет сравнима со сложностью самой задачи, тогда стоит эту оптимизацию опустить и положиться на внутренний аллокатор,
  который аллоцирует место экспоненциально, и поэтому не слишком много времени суммарно на это тратит


* Эту оптимизацию не стоит применять, если предподсчёт итоговой длины контейнера вычислительно сложный (мнемоническое
  правило: сложнее `O(n)`) по тем же причинам, что и в прошлом пункте


* При использовании этой оптимизации не стоит волноваться за переполнение переменной, содержащей длину контейнера и использовать длинную арифметику,
  типа `size_t` абсолютно всегда будет достаточно, потому что если это не так, то это значит, что итоговая длина вашего
  контейнера превосходит, по крайней мере, `2^32`, а тогда даже если каждый элемент вашего контейнера занимает всего 1 байт,
  то речь уже идёт о нескольких гигабайтах данных, которые ваша функция возвращает (а большинство современных машин
  работает на 64-битной архитектуре, и тогда переполнение `size_t` будет означать, что размер итогового контейнера будет по крайней мере `2^64`,
  то есть необходима оперативная память ка минимум в десятки эксабайт, а такого её количества у вас точно не будет).

  Возможно, стоит задуматься над архитектурой вашего приложения и обрабатывать варианты по мере их поступления, 
  а не сначала их вычислять, а потом обрабатывать все скопом
